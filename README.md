# Image Editor 

Emscripten compiles C++ functions into WASM, which is then called by JS. 

WASM modules run in a sandbox environment isolates from the rest of the system, hence cannot access anything outside their own memory space. In this case, JS and C++ cannot directly share the same memory space or allow direct memory manipulation. All "communication" is achieved through allocating some memory, then copying data from that memory space. This is a security feature that prevents malicious code from accessing sensitive resources or interfering with other parts of the application. 

I considered making the kernal computation in `gaussian_blur` known at compile time, but this would require C++23 (since `exp` only became a `const` in C++23) - this is not an issue. The issue lies in the fact that the refactoring would involve using templates for the kernel size and sigma for kernal calculations, and I would have to export multiple `gaussian_blur` functions with fixed variants of kernel and sigma, as they will be called in JS. This introduces the issue of having to limit the sigma and kernel sizes passed by users to a few pre-defined options. 

### Emscripten 
Emscripten is an open-source compiler toolchain that allows you to compile C and C++ code into WASM, so it can run effectively in web browser. 

Run the following in the command line: 

`emcc image_processor.cpp \
  -o image_processor.js \
  -s MODULARIZE=1 \
  -s 'EXPORT_NAME="Module"' \
  -s EXPORTED_FUNCTIONS='["_monochrome_average", "_monochrome_luminosity", "_monochrome_lightness", "_monochrome_itu", "_gaussian_blur", "_edge_sobel", "_edge_laplacian_of_gaussian", "_data_to_layer", "_bucket_fill", "_merge_layers", "_malloc", "_free"]' \
  -s EXPORTED_RUNTIME_METHODS='["ccall", "cwrap", "HEAPU8"]' \
  -s ALLOW_MEMORY_GROWTH=1 \
  -O2` 

It compiles the C++ file and outputs `image_processor.wasm` (the compiled WASM) and `image_processor.js` (the JS wrapper). `_malloc` and `_free` allows JS to allocate and free memory in WASM. `HEAPU8` is used by JS to access raw WASM memory as a Uint8Array. Memory growth in WASM is allowed if needed (such as for large images). 

### Extern C 

`extern "C"` is a directive in C++ that tells the compiler to use C-style naming for functions so they can be called from other languages. C++ mangles function names (adds extra info like parameter types) to support function overloading. This makes the compiler names unreadable or inconsistent for other languages. 

### RGBA 

RGB are the colours red, green, and blue respectively, each in the range 0 - 255. Alpha is the opacity/transparency, also in the range 0 - 255. 

### `Module()` 

Module() is a function generated by Emscripten when compiling C++ to WASM with MODULARIZE=1. It loads the WASM module asynchronously then assigns it to the wasmModule so you can call exported C++ functions. 

### `ccall` and `cwrap` 

Both `ccall` and `cwrap` are provided by Emscripten to call C/C++ functions from JS. 

Key differences: 
- `ccall` calls function immediately, while `cwrap` returns a callable JS function. 
- Use `ccall` for one-off calls, use `cwrap` for repeated calls / better performance. 

### `merge_layers` function in C++ 

In order to optimize for workloads with a large number of layers, this function uses the following algorithm: 

1. Initialize an unordered set of all pixel positions (x,y). This represents the positions in the current canvas that has yet to be fully "set" with some colour. 
2. Process each layer from top to bottom. 
- For the current layer, iterate through its pixel positions (x,y). 
- For each pixel at position (x,y) of the current layer, if it is not in the unordered map then skip. 
- For each pixel at position (x,y) of the current layer, if its alpha channel is 255, then remove (x,y) from the unordered set. This indicates that layers beneath this one cannot contribute to the final colour shown. 
- Use the R,G,B,A information of the current layer to blend it with previous layers. 
3. Continue until either all layers have been processed, or until the unordered set is empty. 

In the worst case, every pixel of every layer is operated on. This would be equivalent to the brute force method. However, when there are a lot of layers, and the top few layers dominate all pixel information of the canvas, the algorithm allows for early termination as all dominating pixel information has already been processed. That is, all pixels on lower levels (that are covered by the top layers) do not have to be processed at all. 

An alternative proposed implementation that does NOT work as well: 

1. For each pixel location (x,y) in the image, calculate its final colour layer by layer, and from top to bottom. 
2. Move on to the next pixel early if the current colour has alpha = 255. 

This method has the same time completity, but constant space complexity as it does not use a set to store the not-fully-processed pixel locations. 

However, from testing, this method has significantly worse actual runtime. This is likely because pixels in the same layer are stored consecutively in memory. Jumping from layer to layer causes significantly more cache misses, requiring the same layer to be retrieved multiple times (up to x * y times). This destroys the CPU cache efficiency. 

# Current features 

## Upload file 

Select image file to upload to browser. 

## Monochromatic filters 

Implement various types, including the average method, the luminosity method, the lightness method, ITU-R BT.709 recommendations for modern digital media (such as YouTube, HDTV, or FFmpeg). 
- The average method is simple but does not reflect human visual perception as it treats all colours equally. `gray = (R + G + B) / 3`
- The luminosity method is the common standard, gives best visual quality and realism. Slightly slower to calculate does to floating point math. `gray = 0.299 * R + 0.587 * G + 0.114 * B` 
- The lightness method keeps the contrast between the brightest and darkest parts, but ignores mid-tone details. `gray = (max(R,G,B) + min(R, G, B)) / 2`
- The ITU-R BT.709 reflects the modern expectations for grayscale conversion. `gray = 0.2126 * R + 0.7152 * G + 0.0722 * B`

## Blurring 

Gaussian blur uses the Gaussian function to soften an image by smoothing pixel values. It is used to reduce noise, reduce details, and to creata a smooth effect. 
- The kernel size determines how many pixels are sampled around each pixel. A larger kernel can capture more of the Gaussian curve, producing a better approximation of the blur. 
- The standard deviation (sigma) controls the strength of the blur. A larger sigma spreads out the weights more, causing a smoother and wider blur. 

## Edge detection 

The Sobel method is a gradient-based edge detection method that computes gradient magnitudes in both x and y directions using 3x3 convolution kernels, good for emphasizing edges and reducing noise. 

The Laplacian of Gaussian (LoG) method is a second derivative-based method that applies the Gaussian blur, then the Laplacian operator to detect edges at points of rapid intensity change. The Laplacian filter implementation is NON-STANDARD. Modifications have been made to make the edges more visible. 

## Colour fill (bucket tool) 

Users are able to select a desired colour (RGBA, hex, or colour wheel), input an error threshold (between 0 and 1), and click the image to fill the area with the input threshold. 

The error bound e between 0 and 1 indicates how "different" a pixel to be filled can be compared to the colour of the pixel selected. e = 0 indicates that the two pixels have identical colour, while e = 1 indicates that they are somewhat different. Please see implementation of `pixels_within_threshold` for details on error bound calculation. 

# Additional functionalities 

## Edge detection 

The Canny edge detector is the standard for many applications. 
1. Apply Gaussian blur (noise reduction). 
2. Compute gradients (Sobel). 
3. Non-maximum suppression (thin edges). 
4. Hysteresis thresholding (track strong/weak edges). 
This method is accurate, clean, and efficient. 

## Image compression 

## Image decompression 

## Undo 

## Redo 

## Revert to original image 

For each unmerged layer, reverting it converts it to its original uploaded image. For merged layers, reverting it converts it to all of its original uploaded image, shown in multiple layers. 

## Merge layers 

Select two or more layers, and click the merge button to merge them into a single layer. The new layer will have the layer id of the lowest layer. 

## Reorder layers 

Drag and drop layers to reorder them, with each layer retaining its layer id information. 

## Name layers and edit layer title 

Give each layer a user-defined name, or rename layers. 

## Save image 

Give users the option to save the image as a PNG or JPEG. 

## Information 

On click of the information symbol beside each tool, users will be shown a description of what the tool does. 

## Movable images 

Images can be moved around on the canvas area. 

## TODO 

- Explain the sigma and kernel for Gaussian Blur 
- Update README with demos of each filter, example use cases 
- CSS styling and design 
- Use SIMD instructions for WASM 
- Check LinkedIn job application requirements 
- Check Figma 
- Design using Figma 
- Open CV library 

Links to consider 

Upscaling image by converting from raster to vector 
https://en.wikipedia.org/wiki/Image_tracing 

https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/ 
https://www.figma.com/blog/speeding-up-build-times/ 


# Known bugs

- Browser sometimes refresh itself, losing all data 

# Design inspirations 

https://www.figma.com/community/file/1423309616378411764/image-editor
https://www.figma.com/community/plugin/1164118094004004837/photopea
https://www.figma.com/community/plugin/1192319987122007459/image-remove-background-upscale-downsize-compress-edit-image 
https://www.figma.com/community/file/1473342027748647996/app-video-image-editing-toolui-component-dark-light-mode-icon-sets 
https://dribbble.com/shots/20268513-Collaborative-Photo-Editing-Software-UI
https://blog.tubikstudio.com/picture-perfect-ui-screens-for-photo-editors/ 
https://github.com/nhn/tui.image-editor

